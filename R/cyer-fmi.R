## FMI and CWT-based CYER Comparison
# Goal: Predict total exploitation rate as a function of FMI (based on GSI
# sampling of marine fisheries + run recronstruction catch estimates)
# 1) Calculate Canadian and total CYER exploitation rates
# 2) Calculate mean proportion of ER associated with US harvest since 2009
# Sep. 10, 2024


library(tidyverse)
library(readxl)

ind_pal <- c("#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99")
names(ind_pal) <- c("CHI", "HAR", "MSH", "SHU", "NIC")

## CLEAN CYER DATA -------------------------------------------------------------

sheet_names <- excel_sheets(
  here::here(
    "data", "ctc", 
    "TCCHINOOK-25-01-Appendix-C-Mortality-Distribution-Tables-Detailed.xlsx"
  ))

stocks <- c("BQR", "CHI", "COW", "HAR", "MSH", "NIC", "PHI", "QUI",
            "EVIN", "RBT", "NWVI", "SWVI", "SHU")
matching_sheets <- sheet_names[
  sapply(sheet_names, function(x) any(grepl(paste(stocks, collapse = "|"), x)))
  ]
matching_sheets2 <- matching_sheets[
  sapply(matching_sheets, function(x) any(grepl("TM", x)))
]
sheet_ids <- which(sheet_names %in% matching_sheets2)


# CWT based CYERs from Laura Tessier
# identify sheets w/ relevant data and associated stock name
new_col_names <- c(
  "year", "cwt_n", "ages", "aabm_seak_t", "aabm_seak_n", "aabm_seak_s", 
  "aabm_nbc_t", "aabm_nbc_s", "aabm_wcvi_t", "aabm_wcvi_s", "isbm_nbc_t", 
  "isbm_nbc_n", "isbm_nbc_s", "isbm_sbc_t", "isbm_sbc_n", "isbm_sbc_s", 
  "isbm_n_falcon_t", "isbm_n_falcon_s", "isbm_s_falcon_t", "isbm_s_falcon_s", 
  "isbm_wac_n", "isbm_puget_n", "isbm_puget_s", "term_seak_t", "term_seak_n",
  "term_seak_s", "term_can_n", "term_can_s", "term_sus_t", "term_sus_n", 
  "term_sus_s", "stray", "esc", "comment"
) 

cwt_dat <- purrr::map2(
  sheet_ids, matching_sheets2, 
  function(x, y) {
    dum <- read_xlsx(
      here::here(
        "data", "ctc", 
        "TCCHINOOK-25-01-Appendix-C-Mortality-Distribution-Tables-Detailed.xlsx"
      ),
      sheet = x,
      skip = 6,
      col_names = FALSE
    )
    colnames(dum) <- new_col_names
    dum %>% 
      mutate(
        indicator = str_split(y, " ") %>% unlist() %>% .[1],
        mark = str_split(y, " ") %>% unlist() %>% .[2]
      ) %>% 
      # remove five year averages at bottom of table
      filter(!grepl("-", year))
  }
) %>% 
  bind_rows()

# southern US harvest not available for 2023; calculate mean values 2016-22 for
# each fishery, add to original dataset for 23 then rescale
cwt_dat_long <- cwt_dat %>% 
  filter(comment == "ok",
         # focus only on unmarked given stocks of interest
         mark == "unmarked") %>% 
  pivot_longer(cols = c(starts_with("aabm"), starts_with("isbm"),
                        starts_with("term"), stray, esc),
               names_to = "strata", values_to = "percent_run") %>% 
  mutate(
    year = as.numeric(year),
    southern_us = ifelse(
      (grepl("falcon", strata) | grepl("_sus_", strata) | 
         grepl("puget", strata) | grepl("wac", strata)),
      TRUE,
      FALSE
    ),
    canadian_er = ifelse(
      (grepl("nbc", strata) | grepl("sbc", strata) | 
         grepl("wcvi", strata) | grepl("term_can", strata)),
      TRUE,
      FALSE
    ),
    missing_from_fmi = ifelse(
      strata %in% c("isbm_nbc_t", "isbm_nbc_n", "isbm_sbc_t", "isbm_sbc_n",
                    "term_can_n"),
      TRUE,
      FALSE
    )
  ) 

# calculate mean southern US exploitation rate to use since 2023 values 
# unavailable
mean_sus <- cwt_dat_long %>% 
  filter(year > 2015 & year < 2023) %>% 
  group_by(strata, indicator) %>% 
  summarize(mean_percent_run = mean(percent_run))


cwt_dat_long2 <- left_join(cwt_dat_long, mean_sus, 
                           by = c("indicator", "strata")) %>% 
  mutate(
    percent_run = ifelse(year == "2023" & southern_us == TRUE,
                         mean_percent_run,
                         percent_run),
    smu = case_when(
      indicator == "NIC" ~ "spring_1.2",
      indicator %in% c("SHU", "MSH") ~ "summer_0.3",
      indicator %in% c("CHI", "HAR") ~ "fall_0.3",
      TRUE ~ NA_character_
    )
  ) %>% 
  filter(
    !is.na(smu)
  ) %>% 
  group_by(
    indicator, year
  ) %>% 
  mutate(
    total_percent = sum(percent_run)
  ) %>% 
  ungroup() %>% 
  mutate(
    scaled_percent = percent_run / total_percent
  )

# calculate Canadian exploitation rate
can_cyer <- cwt_dat_long2 %>% 
  filter(canadian_er == TRUE) %>% 
  group_by(
    indicator, year 
  ) %>% 
  summarize(
    can_er = sum(scaled_percent)
  )


# import Chilko data generated by CW and NK
# cko_dat <- readRDS(here::here("data", "CKO_ERA_Result.RDS"))


#combine stray and escapement, then use to calculate total exploitation
cyer_dat <- cwt_dat_long2 %>% 
  filter(strata %in% c("esc", "stray")) %>% 
  group_by(year, indicator, smu) %>% 
  summarize(
    percent_escaped = sum(scaled_percent)
  ) %>% 
  ungroup() %>% 
  mutate(
    total_er = 1 - percent_escaped
  ) %>% 
  select(
    indicator, smu, year, total_er
  ) %>% 
  left_join(., can_cyer, by = c("year", "indicator")) %>% 
  mutate(
    us_er = total_er - can_er
  ) 


cyer_ts <- ggplot(cyer_dat) + 
  geom_point(aes(x = year, y= can_er)) + 
  geom_point(aes(x = year, y= total_er), color = "red") + 
  facet_wrap(~indicator) +
  ggsidekick::theme_sleek()

us_er_box <- ggplot(cyer_dat) + 
  geom_boxplot(aes(x = indicator, y= us_er)) +
  ggsidekick::theme_sleek()



# check for relative magnitude of exploitation in missing strata

missing_fmi <- cwt_dat_long2 %>% 
  filter(missing_from_fmi == TRUE) %>% 
  group_by(
    indicator, year 
  ) %>% 
  summarize(
    missing_er = sum(scaled_percent)
  )
ggplot(missing_fmi) +
  geom_line(aes(x = year, y = missing_er)) +
  facet_wrap(~indicator) +
  ggsidekick::theme_sleek()



## AMONG STOCK CYER CORRELATIONS -----------------------------------------------

dome_cyer_dat <- read.csv(
  here::here("data", "DOM_CYER.csv")
) %>% 
  janitor::clean_names() %>%
  filter(mort_type == "TM") %>% 
  mutate(
    year = as.numeric(catch_year),
    smu = "spr_1.3",
    nation = ifelse(grepl("CA", fishery_group), "can_er", "us_er"),
    indicator = stock
  ) %>% 
  group_by(
    year, smu, indicator, nation
  ) %>% 
  summarize(
    exp_rate = sum(cyer) / 100
  ) %>% 
  ungroup() %>% 
  pivot_wider(names_from = "nation", values_from = "exp_rate") %>% 
  mutate(
    total_er = can_er + us_er
  ) %>% 
  select(
    colnames(cyer_dat)
  )


library(reshape2)
library(corrplot)


cyer_wide1 <- cyer_dat %>% 
  select(year, indicator, total_er) %>% 
  pivot_wider(names_from = "indicator", values_from = "total_er") 
cyer_wide2 <- rbind(cyer_dat, dome_cyer_dat) %>% 
  filter(year %in% dome_cyer_dat$year) %>%
  select(year, indicator, total_er) %>% 
  pivot_wider(names_from = "indicator", values_from = "total_er") 

cor_foo <- function (x) {
  cor_mat <- cor(x %>% select(-year), use = "pairwise.complete.obs")
  
  corrplot(cor_mat, method = "color", type = "upper",
           tl.col = "black", tl.srt = 45, addCoef.col = "black")
}

cor_foo(cyer_wide1)
cor_foo(cyer_wide2)


## CLEAN FMI DATA --------------------------------------------------------------

# GSI based run reconstruction derived exploitation rates from a) Dobson et 
# al. 2020 (2018 and earlier) and b) Fraser River FMI tech memo (2019-2023); 
# assembled by A Mesmer, updated by C Freshwater to include sector specific 
# ERs in recent years 
rr_cyer_dat1 <-  read_xlsx(
  here::here("data", "dobson_er_data.xlsx"),
  sheet = 1
) %>% 
  janitor::clean_names() %>% 
  mutate(
    year = as.character(year),
    smu = case_when(
      smu == "Sp. 1.2" ~ "spring_1.2",
      smu == "Sp. 1.3" ~ "spring_1.3",
      smu == "Su. 1.3" ~ "summer_1.3",
      smu == "Su. 0.3" ~ "summer_0.3",
      smu == "Fa. 0.3" ~ "fall_0.3",
      TRUE ~ smu
    ),
    # convert percentages to proportional ERs
    across(
      where(is.numeric), ~ .x / 100
    ),
    source = ifelse(
      grepl("Dobson", source), "dobson", "fmi_memo"
    ),
    year = as.numeric(year)
  ) 

rr_cyer_dat_trim <- rr_cyer_dat1 %>% 
  select(year, smu, fmi = total) 



dat <- left_join(cyer_dat, rr_cyer_dat_trim, by = c("year", "smu")) %>% 
  filter(
    !is.na(fmi)
  ) 
saveRDS(dat, here::here("data", "cyer_fmi_dat.rds"))


## EXPLORE COMBINED DATA -------------------------------------------------------

dat <- readRDS(here::here("data", "cyer_fmi_dat.rds"))


# remove years before 2019 when FMI values are dubious
dat_trim <-  dat %>%
  filter(year > 2018) %>% 
  mutate(
    log_can_er = log(can_er),
    log_fmi = log(fmi)
  )

fmi_cyer_cor <- ggplot(dat_trim) +
  geom_point(aes(x = fmi, y = can_er, fill = indicator), shape = 21) +
  # geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  scale_fill_manual(values = ind_pal) +
  ggsidekick::theme_sleek() 


# fit hiearchical slopes model to fmi data with intercept fixed at 0
library(brms)
library(DHARMa)


# random ints
fit_brms <- brm(
  can_er ~ fmi + (1 | indicator), 
  data = dat_trim,
  family = Beta(link = "logit"),  # Beta regression
  prior = c(prior(normal(1, 5), class = "b"),  # Priors for fixed effects
            prior(normal(0, 2), class = "Intercept"),  # Prior for intercept
            prior(exponential(1), class = "phi")),
  chains = 4, cores = 4, iter = 2000, warmup = 1000,
  control = list(adapt_delta = 0.95)
  )
# random slopes and ints
fit_brms2 <- brm(
  can_er ~ fmi + (1 + fmi | indicator), 
  data = dat_trim,
  family = Beta(link = "logit"),  # Beta regression
  prior = c(prior(normal(1, 5), class = "b"),  # Priors for fixed effects
            prior(exponential(2), class = "sd"),
            prior(normal(0, 2), class = "Intercept"),  # Prior for intercept
            prior(exponential(1), class = "phi")),
  chains = 4, cores = 4, iter = 2000, warmup = 1000,
  control = list(adapt_delta = 0.95)
)
# constrained to be nearly through 0 with strong informative prior
fit_brms3 <- brm(
  can_er ~ fmi + (fmi | indicator), 
  data = dat_trim,
  family = Beta(link = "logit"),  # Beta regression
  prior = c(prior(normal(-10, 0.25), class = "Intercept"), # very negative prior near 0
            prior(normal(1, 5), class = "b"),  # Priors for fixed effects
            prior(exponential(50), class = "sd", group = "indicator", 
                  coef = "Intercept"), # very tight prior close to zero for random intercepts 
            prior(exponential(2), class = "sd", group = "indicator", 
                  coef = "fmi"),
            prior(exponential(1), class = "phi")),
  chains = 4, cores = 4, iter = 2000, warmup = 1000,
  control = list(adapt_delta = 0.95)
  )

pred_dat <- expand.grid(
  indicator = unique(dat_trim$indicator),
  fmi = seq(0.01, 0.5, length.out = 30)
)


fit_list <- list(fit_brms, fit_brms2, fit_brms3)

mean_dat <- purrr::map2(
  fit_list,
  c("rand_i", "rand_s", "rand_s_constrained"),
  function (x, y) {
    pred1 <- predict(x, newdata = pred_dat)
    # pred_dat$est <- pred1[,1]
    pred_dat2 <- cbind(pred_dat, pred1)
    
    global_pred <- pred_dat %>% 
      filter(indicator == "SHU")
    pred_fixed <- predict(x, newdata = global_pred, re.form = NA)
    global_pred2 <- cbind(global_pred, pred_fixed) %>% 
      mutate(indicator = "global")
    
    rbind(pred_dat2, global_pred2) %>% 
      mutate(model = y)
  }
) %>% 
  bind_rows() %>% 
  mutate(
    model = factor(model, levels = c("rand_i", "rand_s", "rand_s_constrained"))
  )

pred_cyer_ribbon <- fmi_cyer_cor +
  geom_line(data = mean_dat %>% filter(!indicator == "global"),
            aes(x = fmi, y = Estimate, group = indicator),
            linetype = 2) +
  geom_line(data = mean_dat %>% filter(indicator == "global"),
            aes(x = fmi, y = Estimate)) +
  geom_ribbon(data = mean_dat %>% filter(indicator == "global"),
              aes(x = fmi, ymin = Q2.5, ymax = Q97.5), alpha = 0.2) +
  geom_abline(aes(intercept = 0, slope = 1), colour = "red") +
  facet_wrap(~model) +
  labs(y = "Predicted CWT-based CYER", x = "FMI-based ER") +
  theme(legend.position = "top")
  

pred_list <- purrr::map2(
  fit_list,
  c("rand_i", "rand_s", "rand_s_constrained"),
  function (x, y) {
    new_data <- data.frame(fmi = c(0.05, 0.3))  # Example new fmi values
    
    pp <- posterior_predict(
      x, newdata = new_data, allow_new_levels = TRUE
    )
    data.frame(
      exp_rate = rep(new_data$fmi, each = nrow(pp)),
      est_cyer = as.numeric(pp),
      model = y
    ) %>% 
      group_by(exp_rate) %>% 
      mutate(
        median_cyer = median(est_cyer)
      )
  }
)


dd <- bind_rows(pred_list) 
pred_cyer_ridges <- ggplot(dd) +
  ggridges::geom_density_ridges(aes(x = est_cyer, y = model)) +
  geom_vline(data = dd, 
             aes(xintercept = exp_rate), colour = "red") +
  facet_wrap(~exp_rate, ncol = 1) +
  labs(x = "Predicted CWT-based CYER", y = "Model") +
  ggsidekick::theme_sleek()

pred_cyer_violin <- ggplot() +
  geom_violin(data = dd, aes(x = est_cyer, y = model), draw_quantiles = 0.5) +
  geom_vline(data = dd,
             aes(xintercept = exp_rate), colour = "red") +
  facet_wrap(~exp_rate, ncol = 1) +
  labs(x = "Predicted CWT-based CYER", y = "Model") +
  ggsidekick::theme_sleek()


# sim_dharma <- createDHARMa(
#   simulatedResponse = posterior_predict(fit_brms2, nsim = 1000) %>% t(),  # Simulate responses
#   observedResponse = dat$can_er,  # Use actual response values
#   fittedPredictedResponse = fitted(fit_brms2)[,1]  # Extract fitted values
# )
# plot(sim_dharma)  # Check residuals


calc_pit <- function(y, posterior_pred) {
  # Get the proportion of posterior samples that are less than or equal to the observed value
  n_obs <- length(y)
  pit_residuals <- numeric(n_obs)
  
  for (i in 1:n_obs) {
    # Calculate pmin and pmax for each observation
    y_prime <- posterior_pred[i, ]  # posterior predictions for i-th observation
    pmin_i <- mean(y_prime < y[i])
    pmax_i <- mean(y_prime <= y[i])
    
    # Generate the PIT residuals as a random draw from uniform(pmin, pmax)
    pit_residuals[i] <- runif(1, pmin_i, pmax_i)
  }
  
  return(pit_residuals)
}

# check pit resid
purrr::map2(
  fit_list,
  c("rand_i", "rand_s", "constrained_rand_is"),
  function (x, y) {
    pp <- posterior_predict(x, nsim = 1000) %>% t()
    pit_residuals <- calc_pit(y = dat_trim$can_er, posterior_pred = pp)
    qqplot(qunif(ppoints(length(pit_residuals))), pit_residuals,
           main = paste("QQ-plot of PIT Residuals Model ", y))
    abline(0, 1)
  }
)

png(here::here("figs", "pred_cyer_ribbon.png"), height = 4.5, 
    width = 7.5, units = "in", res = 250)
pred_cyer_ribbon
dev.off()

png(here::here("figs", "cyer-ts.png"), height = 4.5, 
    width = 4.5, units = "in", res = 250)
pred_cyer_ridges
dev.off()

png(here::here("figs", "cyer-ts-violin.png"), height = 4.5, 
    width = 4.5, units = "in", res = 250)
pred_cyer_violin
dev.off()

